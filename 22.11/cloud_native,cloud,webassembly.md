# 1 跨平台
一切的故事要从跨平台说起。现在我们较少的听到程序去强调跨平台了，但是在早些年跨平台绝对是老生常谈的话题。因为那时候没有docker这么方便的工具。而java能火起来也正是因为早年间的一句响亮的口号`Write Once, Run EveryWhere`。为什么跨平台这么重要呢？我们写一个程序，最终运行在机器上，但是真正的运行机器环境可能是不同的，而且可能跟我们写代码的开发机也是不同的。即使是相同的操作系统，但是内核版本的不同也可能导致不兼容。因而早些年我们需要交叉编译，例如在`mac`电脑上写的程序需要借助交叉编译得到能运行在某个`linux`版本上的二进制文件，然后传到服务器上再运行。
# 1.1 VM
此时服务器上一般会运行其上多个虚拟机，程序实际上是在虚拟机里面运行，这也是多方考量，因为宿主机的规格非常高，单个应用占用一台宿主机，资源浪费严重，多进程的运行多个应用在宿主机，隔离性又得不到保障。所以虚拟机VM是一种最佳实践。然而交叉编译并不能解决所有问题，例如代码中使用的一些系统调用函数，在不同OS上是完全不同的，在`mac`上写的代码有时根本无法编译出linux版本的二进制文件，往往我们需要开发机和服务器是相同的操作系统，相同的内核版本，来避免跨平台的错误。本质上来说，做不到相同代码在不同OS上运行，大部分时候都需要进行代码调整。

VM这个重量级实现还存在镜像体积巨大，构建和部署流程繁琐且缓慢等问题，因为启动过程较慢，很多时候宿主机上会启动一部分VM来待命，等待发程序过来执行。
# 1.2 JVM
而java提出了一种更小代价的VM，不需要虚拟出整个操作系统，`jvm`只虚拟出`java`程序的`runtime`环境，`jvm`向上对开发者来说实现功能的函数一致，而向下兼容了多个操作系统，屏蔽了实现细节，实现相同功能可能底层调用的操作系统函数并不相同，但用户无需关心。真正意义上做到了相同代码，可以在不同的平台运行。于是在VM上运行`JVM`，`JVM`中运行java程序，成为一种主流的开发方式，用户可以用`windows`可以用`mac`可以用`ubuntu`，几乎可以用任何想用的开发机来开发程序，都可以成功的发布到服务器上。

`JAVA`是`C++`写的，`C++`部分的代码又叫`native`代码，`native`这个词基本也就定了个跟OS紧密相关的基调，即实现同一功能的`native`的代码是会和OS不同而不同的。`JVM`定义了的`java runtime`是一个完整的“世界”，在里面有自己的内存堆、栈，有自己的线程，开发者只需要了解这个“世界”（jvm）的规则即可，基本不太需要关注OS对应的发生的事情。当然这也有一定的代价，就是我们需要在我们要运行程序的机器上去安装这个运行时`JRE`。
# 1.3 Docker
`VM`是一种很重的实现，启动和扩容都很慢。而`Docker`的出现彻底改变的VM的发展。`Docker`是一种轻量级的虚拟化，本质上docker容器里的程序还是运行在当前宿主机上，是通过借助`cgroup`等工具链把linux上的资源进行了切分，进程级别去瓜分操作系统的资源，只不过`docker`的抽象让用户看起来像是运行在了`vm`里，`docker`启动非常迅速，扩容和销毁非常快，但是因为是假的“VM”，docker的隔离性没有`VM`那样彻底。即使这样，`docker`的轻量、快速和高效还是颠覆了虚拟化和云计算行业。

“如果Docker出现的早一些，可能就不会有jvm了”。这是网上的一种激进的言论，这是因为`docker`的轻量性，使得我们可以在任何机器上使用一个发行版的linux镜像来进行开发，然后最终将开发好的程序连同linux基础镜像build成app镜像，部署到服务器上即可。有了这么轻量的`docker`的加持，好像所有语言都可以实现`Write Once, Run EveryWhere`。但是其实还是做不到`java`这么丝滑。
# 1.4 native
我们上面jvm中提到了`native`是指`c++`部分的代码，他可能因OS不同而有着不同的实现方式。`native`就是操作系统本地化的，这似乎是个贬义词，因为差异化意味着不灵活。但同时这种量身定做也意味着高效，不可能有任何运行方式的效率能超过`native`。于是我们知道最高效的运行方式就是在宿主机运行`native`代码；稍差一些可以加一层抽象：在VM中运行`native`代码，或者在`jvm`中运行`java`代码，或者在`Docker`中运行`native`代码；也可以有两层抽象在`VM/Docker`中运行`JVM`中运行java代码。虽然在很多公司`Docker`+`jvm`的方式也是一种主流，但是肯定是运行效率低于`Docker`+`native`（比如docker中运行c++）。只是因为损失的这点效率，在灵活可扩展，应用场景，语言生态，开发者生态等等的权衡下，变得不值一提（某些公司，不代表全部公司和全部业务场景），才选择了`Docker`+`jvm`这种套娃形式。
# 2 cloud native
云原生这个名字有点迷惑，如果去查该术语的定义会发现，不同的网站给出的定义并不完全相同，只不过他们的都有个共同点，就是看懂了好像又没看懂是在说什么。

![image](https://i.imgur.com/gYIVXH7.png)

![image](https://i.imgur.com/VFZjM5n.png)

![image](https://i.imgur.com/4IXkLMY.png)

![image](https://i.imgur.com/8YeEUGG.png)

`native`就是本地运行的，`cloud native`是在云上就像本地运行程序一样，即把cloud提供的工具做个高度集成就是`cloud native`了（我自己的一种理解方式，不是官方说法）。这里的native是一种比喻的方式，并不是说我们必须只能运行`native`代码了，那样的话java就被抛弃了。都有什么有代表性的cloud工具呢，可以从`CNCF`云原生基金组织的官网来看一些project的list，如下是一些明星选手，像k8s、普罗米修斯、etcd、fluentd。

![image](https://i.imgur.com/NLheJiK.png)

当然cn的项目也远不止这点，官网有张超大的(原图)[https://landscape.cncf.io/]，(冷知识是docker不在CNCF下，docker公司不想依托别人，自己单干，现在处境有点尬，一些管理编排工具干不过k8s，苦苦挣扎)。

![image](https://i.imgur.com/UDhcAs3.png)
## 2.1 golang
cn中很大一部分项目都是基于golang写的，比如docker、k8s等都是golang写的，golang也成了cn上部署应用的常用语言。那golang为什么这么受cloud native欢迎呢。