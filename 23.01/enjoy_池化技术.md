# 池化技术
我们在很多工具很多场景中经常看到池化技术，例如连接池、对象池、线程池，这些都是利用了池化技术，而池化技术本身其实是一种资源复用的出发点。

当我们`创建某些资源有较高的代价`的时候，就可以通过先创建一批这种资源放到池子里，当需要销毁资源的时候，不是真正的销毁而是`返回到池子`中。等下一次再需要该资源的时候，直接将`池子中的该资源`返回去。

这样一来，避免了多次创建和销毁资源，而典型的有较高创建代价的资源有
- tcp连接，三次握手代价较高，对应的池化技术就是连接池，当然针对更细的场景有数据库连接池，http连接池等等。
- OS线程，线程的create/destroy需要进入内核态，代价也很高。对应池化技术就是线程池，线程池在java中又有经典线程池模型和ForkedJoin模型。
- 对象，在特定场景下，对象的创建和销毁也成为了一种负担，一般上层场景较少，底层框架会有大量且频繁使用对象的场景，这时候为了减少对象创建和销毁就会使用对象池，本文不对该对象池做讨论，主要对连接池和线程池做展开。
# 1 数据库连接池
主要以最火的`Hikari`的源码为例，展开分析。上面我们知道了连接池的目的就是复用tcp连接，说白了就是复用`Connection`对象，通俗讲就是我们可以事先创建很多个`jdbc Connection`放到一个池子中，等使用的时候从中拿，用完了再还回来。

![image](https://i.imgur.com/v3RYLtK.png)

这个过程如上图，好像Pool的实现并不麻烦，只需要一个队列和维护队列`push/poll`的方法就可以了。然而实际上，数据库连接池还需要一些繁琐的“运维”工作，例如
- 1 维持连接的鲜活的keepLive，可能是每过多少秒看看tcp是否正常。
- 2 检查DB的心跳heartbeat，可能也是每多少秒的心跳操作与上面类似。
- 3 如果一个连接失效了，可能是被db断开也可能是超过一定寿命了，需要被清理的操作。
- 4 清理完，得进行补充以达到设定的poolSize。
- 5 等等

“运维”工作是必须做的本分，此外还要考虑并发和性能问题，例如多线程同时想获取连接，怎么避免把同一个conn给了多个线程等。

我们来看一下hikari的设计。