# mysql
本文从到到尾梳理mysql的知识点，主要用于面试的复习，内容主要分为以下几个部分：
- 1存储引擎的对比
- 2底层是如何组织存储的
- 3索引
- 4buffer Pool
- 5bin log
- 6redo log
- 7undo log
- 8mvcc
- 9锁
# 1 存储引擎的对比
![image](https://i.imgur.com/YbMkQSh.png)
# 2 底层是如何组织存储的
## 2.1 行结构
![image](https://i.imgur.com/ZgiHxA0.png)

以`compact`格式为例：一行数据结构如上图，分为额外信息和真实的列值数据两部分，额外信息中需要记录变长列的长度，因为是变长的无法提前知道长度，所以需要随着每条记录做标记；null值列表主要是null不会在数据部分做任何存储，只在这里存储列名；记录头信息内容比较多，比如有指向下一条记录的指针，deleted标等。

一行数据不能太长，最长是700多个字节，超出的部分就算溢出，当前数据记录一个指针，超出的部分单独放到溢出页，指针指过去，可能有多个溢出的列。
# 2.2 页结构
每一行数据是一个record，record是通过页的方式管理起来的，一个页是16KB，一页中存放多行数据。这是页的组成，数据就是放在`User Records`部分。

![image](https://i.imgur.com/AJbRGPf.png)

需要简单介绍下: 
- `Infimum/Supremum`，这两个分别是标志着这一页的最小和最大的记录，是虚拟的记录，并不真正存储数据，可以认为是dummy指针，Inf的next指向页中的第一条有效数据，而最后一条数据的next指向Sup。
- 页与页之间也通过`FileHeader`中的prev、next连接成双链表。所以页面的整体组织方式如下图。

![image](https://i.imgur.com/505xJ1z.png)

- `PageHeader`则记录数据页内的元数据信息，非数据页就不需要这个字段，例如Index_id(当前页属于哪个索引)，B+树层级等等
- `FileTailer`是一个校验信息的位置
- `PageDirectory`是比较重要的数据，首先将`Inf`作为一个分组，`Sup`和往前最多8条数据为一个分组，中间的数据最多4条为一个分组，通过此方式将页内数据进行分组，每一组最后一条数据的记录头中`n_owned`字段记录了该组一共多少条数据，并且`PageDirectory`存储每个分组最后一条数据的地址，因为分组数取决于数据量，这部分的大小=地址长度x分组数，所以也是不确定大小的。通过这个目录，再查询当前分页的数据时就可以实现二分查找。
## 2.3 区与段
B+的最小组织单位就是页，但是如果按照页来组织整个磁盘的存储，仍有些不妥，尤其是读取大量连续数据的时候，可能会跨多个页，此时如果两个先后关系的页，物理上地址很远，IO也是比较慢的。例如下面索引这一节的图中，页34,35,36,40如果在磁盘上是相去甚远的不同地方，那么读取就会变慢。所以有了区。

一页是16k，64个连续的页成为一个区，也即是1M一个区。这样可以将连续的数据页放到一个区内，连续的目录页也可以放到一个区内。内存读取的最小单位是页，磁盘分配的最小单位是区，因为但分配一个页的代价比较大，且导致不连续性对性能是很大的损失。

另一个概念就是段，段是逻辑意义上的区分，例如聚簇索引中所有的叶子节点是`叶子节点段`，其他是`非叶子节点段`，段是纯逻辑概念，他并不一定由一个或多个完整的区组成，因为区是物理概念，两者没有交集。只能说段至少有一页组成。
## 2.4 数据更改时页的变化
先说insert，当插入数据的时候找到要插入的页。然后看页是否已经满了，如果没有满的话，则需要在`PAGE_FREE`也就是已删除的数据链表找最近一条已删除的记录，看空间够不够放下当前记录，够的话就用，不够则在当前页的`FreeSpace`中申请一部分插入当前数据，并通过`next`指针的修改，插入到当前页的数据链表中，注意这里不改变原来页内的数据。例如当前页有以下数据，并希望插入9这条数据，其他数据的物理位置不发生变化，只是在后面插入9，并把8的next指向9的地址，9的next指向10的地址即可，此外插入可能还会导致组的变化`n_owned`等字段，以及`PageDirectory`和`PageHeader`中一些元数据的修改。

而如果页面满了则有两种情况，一种就是下面会说的虽然满了，但是其实碎片空间是足以称下这条记录的，收拾收拾还能用；另一种就是实在装不下了，就只能新开新的页，这个过程又叫分裂。

![image](https://i.imgur.com/Cf17QH2.png)

然后对于update，如果更新后的记录长度没有变化，就可以复用当前record的磁盘空间，就地更新(p353)。如果不一样大，则会先删除再创建的方式，也就是删掉原来的记录，然后添加一条新的记录，因而这种情况一句update，会产生两个undolog的日志，后面讲到。

最后对于delete，则是先把deleted标识改为true(事务执行中的中间状态)，然后事务提交后，把这条从链表中拆下来，扔到`PAGE_FREE`这个已删除记录的链表中（该过程为purge），将可能用于insert新纪录去复用。`PAGE_FREE`链表在特定的时机也会被后台线程清理。

![image](https://i.imgur.com/wJ3WK5n.png)

这里有一些碎片问题，例如删除的数据记录都很长，新插入的都很短，导致复用的记录空间是比较大的利用率比较低。所以有个兜底逻辑就是对应上面insert里说的虽然满了，但是记录的`PAGE_GARBAGE`中有碎片的大小信息，发现是可以承载当前要插入的record，那么就把当前重新紧凑排列，规整一下，插入这一record，具体方法是create一个临时页，按顺序排排坐，然后排好了再copy回来，删掉临时页。

# 3 索引
通过B+树的方式组织索引，上面介绍的页结构是数据页的结构，在页内可以使用二分查找，但是如何找到数据页就需要用到索引。B+树是一种多叉搜索树，可以有效的降低查询复杂度。树的每个节点是一个页，其中叶子节点是真正存储数据的，又叫`数据页`，而其他节点只存储索引值+页号，叫做`目录页`，数据页和目录页都是索引页`index`类型的页。下图中每条记录的类型用数字0123表示了，0就是真实的数据记录，1就是只有索引+页号的记录，2是Inf记录，3是Sup记录。

![image](https://i.imgur.com/qquE86B.png)

## 3.1 聚簇索引与二级索引
聚簇索引又叫主键索引，上面图中的就是聚簇索引，他的叶子节点记录的数据是完整的数据。但是table除了主键还可能加其他列作为索引，这些就是二级索引，二级索引也会创建B+树，只不过叶子节点不再需要存储所有列的内容，只需要存储主键和索引列的值两项即可，找到主键后再回到聚簇索引查对应的其他列数据即可，这个过程叫`回表`，此外目录节点也需要存储`主键`+`索引列`，而不是只存索隐列，这样提前命中就可以更早的去回表，如下是二级索引的树结构。橘色是二级索引列，深蓝是主键值。

![image](https://i.imgur.com/MEmoHvb.png)
## 3.2 联合索引
联合索引是将多个列同时作为索引，底层也是建立一个B+数，只不过需要同时存储多个列和主键的值，B+节点的大小排序是先按照联合的第一列排序，如果第一列一致，就按照第二列排序，第二列一致，就按照第三列，以此类推。

因而联合索引可以按照最左匹配来起到索引的效果，例如a、b两列的联合索引，就可以被`where a=1 and b=2`这种查询命中，也可以被`where a=1`这种命中，但是`where b=2`就不能使用这个联合索引。而对于range条件`where a>1 and a<10 and b=1`这个查询就可以使用该索引，因为可以感觉a的条件进行索引找，`b=1`不能用该索引，需要`a>1 a<10`拿出数据挨着比较b是否=1。

# 4 Buffer Pool
读数据的最小单位是16k的页，如果同时要从一个页读两条不同的数据，那就可以把这页缓存到内存中，减少IO，基于这样的想法就有了BufferPool这个内存额定大小的空间，来缓存数据，BufferPool简称BP吧，他由两部分组成，控制块和缓冲页，缓冲页是存储内存页数据的只不过结构上稍有变化，并且缓冲页大小也是16k。控制块则是记录很多元信息的。

![image](https://i.imgur.com/dPKWqSo.png)
## 4.1 free与flush链表
把空闲的缓冲页的控制节点串成一个链表，就是free链表，主要用来用的时候可以从这个链表分配，而当分配后如果有写操作，就会修改缓冲页中的值，导致和磁盘页不一致，称为脏页，脏页的控制节点也串成一个链表，叫flush链表，下面是两个链表示意图，一个控制块要么是free要么flush，也可能都不是，都不是的就是普通的读缓存节点，没有update操作过。另外如何根据物理磁盘页信息找到内存中的缓冲页呢，因为是个链表，O(n)显然不可取，所以有个专门的HashTable维护了表空间-页号和buffer页的对应关系。

![image](https://i.imgur.com/fOLKc89.png)
![image](https://i.imgur.com/GsdqZu2.png)
## 4.2 LRU链表
从磁盘读到内存的页，都会放到LRU链表中，也就是说LRU链中的节点是由flush链表的所有节点和另一部分只读没写的节点组成的。

mysql的LRU有很多改进，例如为了减少热点数据频繁在链表中移来移去，退出了前3/4个节点是young区，后1/4是old区，young区节点被访问后需要先判断距离上次被访问的时间是否大于一个阈值时间，如果没有就不移动了，因为young短时间也不会有被驱逐的危险，老年人才会被优先淘汰，这样减少了LRU的频繁操作。
## 4.3 脏页落盘
数据刷新到磁盘，是一个后台线程定期执行的，有两种刷新方式：
- 从LRU的old中刷脏页(跳过不是脏页的old)
- 从flush链表中刷一部分

# 5 bin log
Binlog是记录所有数据库表结构变更以及表数据修改的二进制日志，不会记录SELECT和SHOW这类操作，主要用于数据恢复和主从同步。写入时机是事务提交的时候。

![image](https://i.imgur.com/4MVEr63.png)

文件记录模式有STATEMENT、ROW和MIXED三种。

STATEMENT记录每次执行的sql，日志小，但是有些sql有毒比如`now()`，可能导致恢复的时候与之前数据不一致。ROW记录每一行被改的数据，能还原所有的细节，但是如果有加一列这种操作，可能导致全表都得生成binlog。所以目前mysql采用的是MIX混合模式，即通过当前sql判断要用哪种，没有`now()`这种有状态函数的就用statement，否则就用raw。

redo log 用来保证 crash-safe，binlog 用来保证可以将数据库状态恢复到任一时刻。
# 6 redo log
redo log也是用来记录执行的数据变动的，但是他是innodb存储引擎级别的，并且存储的是数据页的变动，并且是顺序写，性能更好。

update数据的过程是，读取出要改的数据页，扔到上文提到的`BufferPool`中，然后对页进行更改，当事务提交后，对应的缓冲页会扔到`flush`链，我们上文说系统会定期刷新flush链的内容。不过漏掉了细节，就是对页进行更改后，需要将更改的内容以redolog的形式进行持久化。redolog的生成过程，也需要现将生成的内容以`redo log block`的形式放到`LogBuffer`中，然后等`LogBuffer`刷盘，有两个时机是必须刷盘的：
- 1 事务提交的时候，必须刷盘，虽然事务提交`BufferPool`中的flush链表可以不立即刷盘，但`LogBuffer`必须立即同步刷盘。
- 2 flush链表中脏页要刷新到磁盘之前，脏页如果要刷新到磁盘，必须保证他的`LogBuffer`中对应的redolog日志先刷盘完成。

当然刷盘时机还有其他，比如做checkpoint时，每秒定期等，但是上面2条能保证，刷盘到DB磁盘的数据，一定在redolog磁盘中了。这样才能保证crash-safe，而binlog就做不到，因为binlog只是记录了sql，可能sql执行了，但是还没有刷盘DB，这样binsql中就多记录了数据，无法保证crash-safe。

## 6.1 redolog文件组
redo log是指定的文件个数的，比如设置了3个文件，那么就是xx.0 xx.1 xx.2这三个文件，每个文件大小也是指定的，当.2文件写满的时候，就会覆盖.0文件。redo log是用来崩溃恢复的，所以对于已经存到db磁盘的数据的redolog就不再需要了，因而可以循环利用文件组。但是需要保证确实被覆盖的部分数据，确实已经刷盘到DB了，所以有了checkpoint的概念，他是专门检查当前已经刷到DB磁盘的序号。

恢复的时候，就从checkpoint开始，往后读block，直到有个block的size不是512了，说明这里崩溃的，恢复之前的。

![image](https://i.imgur.com/9LNUASI.png)

## 6.2 MTR的原子性
在进行事务操作的时候，改动都是先写Buffer Pool，然后由redolog记录，redolog被分为很多个不可分割的”组”，例如某个insert操作中，主键的max值自增是一个组，插入b+树数据是一个组。而b+树插入可能有很多步骤，尤其产生分裂的时候，如何保证这个组不可分割，那就在redo中以一个特殊标志位标识是组的最后一个log完成。这样就能在恢复的时候，不至于只恢复半个组，导致数据不一致。我们把只包含一个分组的这个操作叫做(MTR)最小事务，一个MTR对应不可分割的redolog组。
# 7 undo log
undo log与事务回滚和mvcc的版本链都有关系，mvcc我们后续介绍，undo log本质是为了记录对数据的操作历史记录。

一行数据3个隐藏字段`row_id`，`trx_id`，`roll_pointer`。其中事务id就是当前的事务的id，roll_pointer则是指向上一次事务修改的数据，这个数据就在undo log中。因而当事务中修改数据的时候，需要将老的数据扔到`undo_log`的数据页中新的数据通过指针指向老的数据。这样如果事务回滚的话，只需将老的数据恢复回来即可。

## 7.1 undo页
与redo log不同，undo log和db一样用页的方式组织的，有一种专门的page_type就是undolog类型。这是因为undo log是事务相关的，一个事务需要自己的undo log链，而redo log是物理页的改动记录，与逻辑层无关，所以可以无脑顺序写。

undolog对不同的增删改操作生成的log结构并不相同，
- 对于新增操作需要记录新增的id即可；
- 对于修改操作则需要记录改动前的旧值(只记改的列)；
- 而对于删除操作稍微不太一样，需要记录删除前的样子，并且还不能直接把主索引树种的记录删除，因为删了的话就没法link到undolog了，所以是把原来的记录打一个delete标志，然后把所有的列值记录到undolog中。

对于insert和非insert，有两个链表insert链和update链（虽然叫update其实也包含delete），而对于临时表和普通表也是分开的，所以一个事务对应的undo log会有0~4个redo log链。

![image](https://i.imgur.com/zJOOhJ0.png)

insert undo链表 中只存储类型为 TRX_UNDO_INSERT_REC 的 undo日志 ，这种类型的 undo日志 在事务提交之后就没用了，就可以被清除掉。所以在某个事务提交后，重用这个事务的 insert undo链表 （这个链表中只有一个页面）时，可以直接把之前事务写入的一组 undo日志 覆盖掉，从头开始写入新事务的一组 undo日志 ，如下图所示

![image](https://i.imgur.com/Ms00fV4.png)

但是update链就稍微特殊，因为事务提交后，也不代表undolog可以删除，因为mvcc追溯版本可能还会追溯到提交后的历史事务中来，所以page可以重复利用空闲的部分，但是原来的数据不能改。

![image](https://i.imgur.com/2baII8z.png)
## 7.2  