# 编译与链接
## 1 编译与解释
编程语言可以分为编译型语言和解释型语言，编译型语言就是把源码通过编译器编译成机器码即二进制可执行文件，直接运行可执行文件就可以运行程序，例如c语言、golang、rust都是编译型语言。而解释型语言原则上不需要处理代码源文件，直接由解释器逐行解释代码来运行，例如python、js和java都是解释型语言。

对于java稍微说一句，java由javac“编译”成`.class`文件，并不是机器码，而是jvm的一种规范的文件形式，本质上是实现了一种统一的跨平台的文件格式规范，让解释器更统一的解释代码。但是jvm运行时的`JIT`及时编译，可以对常用的代码块在运行时编译成机器码，因为是运行时编译，可以更好的跨平台。所以严格来讲java是一种半解释半编译型语言。

## 2 动态链接与静态链接
以前学c语言老师让用vc++6.0，里面有三个重要的步骤：编译->连接->运行。链接是很重要的步骤，链接的本质是将用到的c语言库进行引入。两种连接方式分别是动态和静态的链接，其中最常用的是动态链接。

例如最简单的打印`hello world`程序如下，`stdio`是标准的io库，他在libc这个库中，需要链接进来。
```c
// hello.c
#include <stdio.h>

int main() {
    printf("hello world\n");
}
```
我们通过指令`gcc -o gnu_c_dyn_hello hello.c`将源码进行编译得到文件`gnu_c_dyn_hello`这里文件名是为了和后面的其他方式区分。如下图，我们很容易得到了编译和链接后的二进制文件，并将其运行起来了。其实我们没有特别去指定链接，gcc回到系统默认的libc库中去进行动态链接。通过`ldd`指令也可以看到动态链接的库名，和对应的所在的文件路径，这里默认是`/lib/xxx`这个路径下的so文件，linux下的动态链接库后缀是so，windows下是dll。

![image](https://i.imgur.com/Dx2d9Vv.png)

动态链接的好处是，像`libc.so`的库是非常常见的，很多程序中都要用到，如果每个程序都将该功能引入，文件就会变大，且直接加载到内存也会占用较多的内存空间，而通过动态链接的方式，动态库是在共享的内存空间，所有的进程都用的函数在内存中是共享的，节省内存。但是动态链接的坏处也很显著，即如果把二进制文件放到没有安装对应的libc的linux中就无法运行了，会报共享库缺失的错误，此外共享库需要有很好的兼容性。

动态链接的缺点与优点刚好就和静态链接相反了，静态链接执行文件变大，内存占用变多，但是所有的功能都封到二进制文件中了，不需要依赖系统是否有合适的lib库。我们通过`gcc -static -o gnu_c_static_hello hello.c`得到静态链接的二进制文件，如下同样可以执行，并且我们看到静态链接的文件有870k而动态链接的只有16k。

![image](https://i.imgur.com/3lww38W.png)

静态链接的文件可以在没有gnu库的linux下也能运行，例如我们启动一个alpine的docker来执行下这两个文件，动态链接的文件报错说`not found`并不是文件不存在，是这个动态链接的二进制找不到他链接的so文件或者找到了但是不太匹配，因而无法运行。

![image](https://i.imgur.com/JsMmloC.png)

在alpine中运行ldd得到输出如下，可以看到动态链接的文件libc链接到了alpine系统中的so文件了，但是我们在ubuntu下编译用的是glibc和alpine中的musl libc其实并不相同，所以so文件并不匹配导致无法运行，下面会说gnu和musl。

![image](https://i.imgur.com/31mZVMg.png)

## 3 gnu与musl

## 4 c、golang与rust的跨平台交叉编译