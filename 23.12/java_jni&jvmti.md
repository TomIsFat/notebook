# jni java native interface
jni是java调用native代码的一种机制。

例如我们写一个java类，里面用到`native`方法`add`
```java
package com.jni;

public class JNIDemo {

    private native int add(int a, int b);

    static {
        System.loadLibrary("MyJNI");
    }

    public static void main(String[] args) {
        int s = new JNIDemo().add(1, 1);
        System.out.println(s);
    }
}
```
然后生成h文件
```bash
# 如果有javah则也可以直接用javah指令
$ javac -h . com/jni/JNIDemo.java
```
到此得到以下文件目录

![image](https://i.imgur.com/6EoAmR7.png)

打开h文件看一下内容如下，就是定义了一个`Java_com_jni_JNIDemo_add`方法，该方法签名格式是固定的，我们不需要管他。
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_jni_JNIDemo */

#ifndef _Included_com_jni_JNIDemo
#define _Included_com_jni_JNIDemo
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_jni_JNIDemo
 * Method:    add
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_com_jni_JNIDemo_add
  (JNIEnv *, jobject, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
```
接下来实现h文件中的方法，写一个`demo.c`文件如下
```c
#include <jni.h>
#include "com_jni_JNIDemo.h"

// JNIEXPORT是一个宏定义用来输入JNI格式， jint是返回值类型，是java中的int
// JNICALL：也是一个宏定义，用于指定函数调用约定，函数名Java_<全限定类名>_<方法名>
// 参数前2个分别是jni的环境，java中this对象和两个入参jint类型的a，b
JNIEXPORT jint JNICALL Java_com_jni_JNIDemo_add
  (JNIEnv * env, jobject instance, jint a, jint b) {
    return a + b;
}
```

然后通过gcc将文件编译成动态链接库，这里以linux为例，注意so文件名一定是`lib`开头，后面的`MyJNI`与java中`System.loadLibrary("MyJNI");`部分保持一致。编译完之后，需要把so文件扔到`/usr/java/packages/lib, /usr/lib64, /lib64, /lib, /usr/lib`这几个目录之一，否则加载时找不到。
```bash
$ gcc -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/linux" -shared -o libMyJNI.so demo.c
$ cp libMyJNI.so /usr/lib
```
![image](https://i.imgur.com/yC5osts.png)

当然也可以在java中通过绝对路径的方式制定so文件
```java
System.loadLibrary("/path/to/so/xx.so");
```
# JVMTI jvm tool interface
JVMTI提供了一些对于jvm的监控性的api，也需要在jni下才能调用，即引入`jvmti.h`头文件，即可使用jvmti。

例如写一个查看jvm中某一个`Class`的instance列表(最多取10个避免oom)。

```java
package com.jvmti;

import java.util.*;

public class JVMTIDemo {
    static { System.loadLibrary("MyJVMTI");}
    private native Object[] getInstance(Class cls);

    public static void main(String[] args) {
        List<A> list= new ArrayList<>(); 
        for (int i = 0; i < 10; i++) {
            A a = new A();
            System.out.println(a.hashCode());
            list.add(a);
        }

        for(Object obj : new JVMTIDemo().getInstance(A.class)) {
            System.out.println(obj.hashCode());
        }
    }
}
class A {}
```
此时用`javac -h . com/jvmti/JVMTIDemo.java`得到的头文件`com_jvmti_JVMTIDemo.h`如下
```h
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_jvmti_JVMTIDemo */

#ifndef _Included_com_jvmti_JVMTIDemo
#define _Included_com_jvmti_JVMTIDemo
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_jvmti_JVMTIDemo
 * Method:    getInstance
 * Signature: (Ljava/lang/Class;)[Ljava/lang/Object;
 */
JNIEXPORT jobjectArray JNICALL Java_com_jvmti_JVMTIDemo_getInstance
  (JNIEnv *, jobject, jclass);

#ifdef __cplusplus
}
#endif
#endif
```
接下来写个`MyJVMTI.c`文件如下
```c
#include <jni.h>
#include <jvmti.h> # 注意引入jvmti
#include "com_jvmti_JVMTIDemo.h"

JNIEXPORT jobjectArray JNICALL Java_com_jvmti_JVMTIDemo_getInstance
  (JNIEnv * env, jobject instance, jclass cls) {
jvmtiEnv *jvmti;
    (*env)->GetJavaVM(env, &jvmti); // 获取Java虚拟机实例
    (*jvmti)->GetEnv(jvmti, (void **)&jvmti, JVMTI_VERSION_1_2); // 获取JVMTI环境实例

}
```