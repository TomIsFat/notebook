---
title: 语句求值2
tags:
    - 编译原理
    - 解释器
    - 面向对象
    - 原型链
---
# 面向对象
面向对象是一个复杂的概念，我们的语言中想要实现两个重要的面向对象特性：继承和多态。在语法分析章节中，我们支持了`class`的声明和创建`new`语法如下：
```js
// class中由多个赋值表达式组成，如果赋值的是函数类型，则该函数的this指向实例对象，super指向父类
// constructor是一个预留的函数名，为构造方法，该方法必须以`super()`开头，调用父类的构造方法
class Person {
    age = 10;
    constructor = function(name, age) {
        super();
        this.name = name;
        this.age = age;
    }
    say = function() {
        print(this.name+ " is "+ this.age + " years old.");
    }
}

new Person("John", 20).say();
```
面向对象有两种主要的实现方式：`class`和`prototype`，前者最为常见，大多数面向对象语言都采用了`class`形式实现。
## class形式
以java为例，先来思考这段代码的打印结果
```java
class A {
    int age = 1;
    public void printAge() {
        System.out.println(this.age);
    }
}

class B extends A {
    int age = 2;
    public void printAge() {
        super.printAge();
        System.out.println(this.age);
    }
}

new B().printAge();
```
打印结果为`1` `2`也就是B这个对象中存储了两个`age`字段，使用`lucene-core`打印`System.out.println(RamUsageEstimator.shallowSizeOf(new B()));`结果为24（对象头8+4 两个age 4+4，取整得到24）,如果只有一个age的话是16.
```
<dependency>
    <groupId>org.apache.lucene</groupId>
    <artifactId>lucene-core</artifactId>
    <version>6.6.1</version>
</dependency>
```
上面例子说明两个事情：
- 1 `java`同名方法会动态调用，也就是多态特性，b对象先到自己的类元信息中找`printAge`方法找到了就用自己这个方法的。
- 2 与方法不同字段是静态绑定的，`super.printAge`找到了A的`printAge`方法，这里打印的是A类中的`age=1`，也就是当前对象有`A#age`和`B#age`，在A类中的方法的`this.age`指向的其实是`this.A#age`。

他的实现原理大概是，b对象的对象头有`Klass point`指向B这个类的元数据信息，这些信息包括了`B`这个类的父类、接口、字段、方法等信息，而在`new B()`的时候，会根据这个元数据信息来创建一个`B`类的对象，然后把`B`类的对象赋值给`b`变量，创建对象要知道对象到底占用内存有多大，需要遍历`B`类的所有父类，按顺序排列所有的字段，对象类型是4字节引用，其他基础类型按照各自大小计算，这样就把每个字节紧凑排列起来了。换句话说b对象里存的俩age是`12`这个挨着的8个字节存放的，而具体前四个字节是`A#age`后四个是`B#age`，则是按照元数据信息顺序算出来的。

`class`形式非常简单、清晰。

## prototype形式
`prototype`是另一种实现面向对象的方式，比较少见，我知道的只有`js`采用了这种设计。